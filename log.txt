============================= test session starts =============================
platform win32 -- Python 3.12.7, pytest-8.4.2, pluggy-1.6.0 -- D:\Dev\kittygram_final\venv\Scripts\python.exe
rootdir: D:\Dev\kittygram_final
configfile: pytest.ini
testpaths: tests/
collecting ... collected 13 items

tests/test_connection.py::test_link_connection[taski_domain] PASSED      [  7%]
tests/test_connection.py::test_link_connection[kittygram_domain] FAILED  [ 15%]
tests/test_connection.py::test_projects_on_same_ip FAILED                [ 23%]
tests/test_connection.py::test_kittygram_static_is_available FAILED      [ 30%]
tests/test_connection.py::test_kittygram_api_available FAILED            [ 38%]
tests/test_dockerhub_images.py::test_dockerhub_images_exist PASSED       [ 46%]
tests/test_files.py::test_infra_files_exist PASSED                       [ 53%]
tests/test_files.py::test_deploy_info_file_content PASSED                [ 61%]
tests/test_files.py::test_backend_dockerfile_exists PASSED               [ 69%]
tests/test_files.py::test_backend_dokerfile_content PASSED               [ 76%]
tests/test_files.py::test_workflow_file PASSED                           [ 84%]
tests/test_files.py::test_requirements_location PASSED                   [ 92%]
tests/test_files.py::test_docker_compose_prod_file_exists FAILED         [100%]

================================== FAILURES ===================================
___________________ test_link_connection[kittygram_domain] ____________________

deploy_file_info = (WindowsPath('D:/Dev/kittygram_final/tests.yml'), 'tests.yml')
deploy_info_file_content = {'dockerhub_username': 'pavellagerev', 'kittygram_domain': 'https://kittygram-final10.duckdns.org', 'repo_owner': 'Chashkapluy1', 'taski_domain': 'https://taski-docker10.duckdns.org'}
link_key = 'kittygram_domain'

    def test_link_connection(
            deploy_file_info: tuple[Path, str],
            deploy_info_file_content: dict[str, str],
            link_key: str
    ) -> None:
        link = _get_validated_link(deploy_file_info, deploy_info_file_content,
                                   link_key)
>       response = _make_safe_request(link)
                   ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_connection.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

link = 'https://kittygram-final10.duckdns.org', stream = False

    def _make_safe_request(link: str, stream: bool = False) -> requests.Response:
        try:
            response = requests.get(link, stream=stream, timeout=15)
        except requests.exceptions.SSLError:
            raise AssertionError(
                f'Убедитесь, что настроили шифрование для `{link}`.'
            )
        except requests.exceptions.ConnectionError:
            raise AssertionError(
                f'Убедитесь, что URL `{link}` доступен.'
            )
        expected_status = HTTPStatus.OK
>       assert response.status_code == expected_status, (
            f'Убедитесь, что GET-запрос к `{link}` возвращает ответ со статусом '
            f'{int(expected_status)}.'
        )
E       AssertionError: Убедитесь, что GET-запрос к `https://kittygram-final10.duckdns.org` возвращает ответ со статусом 200.
E       assert 500 == <HTTPStatus.OK: 200>
E        +  where 500 = <Response [500]>.status_code

tests\test_connection.py:49: AssertionError
__________________________ test_projects_on_same_ip ___________________________

deploy_file_info = (WindowsPath('D:/Dev/kittygram_final/tests.yml'), 'tests.yml')
deploy_info_file_content = {'dockerhub_username': 'pavellagerev', 'kittygram_domain': 'https://kittygram-final10.duckdns.org', 'repo_owner': 'Chashkapluy1', 'taski_domain': 'https://taski-docker10.duckdns.org'}
kittygram_link_key = 'kittygram_domain', taski_link_key = 'taski_domain'

    def test_projects_on_same_ip(
            deploy_file_info: tuple[Path, str],
            deploy_info_file_content: dict[str, str],
            kittygram_link_key: str, taski_link_key: str
    ) -> None:
        links = [
            _get_validated_link(deploy_file_info, deploy_info_file_content,
                                link_key)
            for link_key in (kittygram_link_key, taski_link_key)
        ]
>       responses = [_make_safe_request(link, stream=True) for link in links]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_connection.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

link = 'https://kittygram-final10.duckdns.org', stream = True

    def _make_safe_request(link: str, stream: bool = False) -> requests.Response:
        try:
            response = requests.get(link, stream=stream, timeout=15)
        except requests.exceptions.SSLError:
            raise AssertionError(
                f'Убедитесь, что настроили шифрование для `{link}`.'
            )
        except requests.exceptions.ConnectionError:
            raise AssertionError(
                f'Убедитесь, что URL `{link}` доступен.'
            )
        expected_status = HTTPStatus.OK
>       assert response.status_code == expected_status, (
            f'Убедитесь, что GET-запрос к `{link}` возвращает ответ со статусом '
            f'{int(expected_status)}.'
        )
E       AssertionError: Убедитесь, что GET-запрос к `https://kittygram-final10.duckdns.org` возвращает ответ со статусом 200.
E       assert 500 == <HTTPStatus.OK: 200>
E        +  where 500 = <Response [500]>.status_code

tests\test_connection.py:49: AssertionError
_____________________ test_kittygram_static_is_available ______________________

deploy_file_info = (WindowsPath('D:/Dev/kittygram_final/tests.yml'), 'tests.yml')
deploy_info_file_content = {'dockerhub_username': 'pavellagerev', 'kittygram_domain': 'https://kittygram-final10.duckdns.org', 'repo_owner': 'Chashkapluy1', 'taski_domain': 'https://taski-docker10.duckdns.org'}
kittygram_link_key = 'kittygram_domain'

    def test_kittygram_static_is_available(
            deploy_file_info: tuple[Path, str],
            deploy_info_file_content: dict[str, str],
            kittygram_link_key: str
    ) -> None:
        link = _get_validated_link(deploy_file_info, deploy_info_file_content,
                                   kittygram_link_key)
>       response = _make_safe_request(link)
                   ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_connection.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

link = 'https://kittygram-final10.duckdns.org', stream = False

    def _make_safe_request(link: str, stream: bool = False) -> requests.Response:
        try:
            response = requests.get(link, stream=stream, timeout=15)
        except requests.exceptions.SSLError:
            raise AssertionError(
                f'Убедитесь, что настроили шифрование для `{link}`.'
            )
        except requests.exceptions.ConnectionError:
            raise AssertionError(
                f'Убедитесь, что URL `{link}` доступен.'
            )
        expected_status = HTTPStatus.OK
>       assert response.status_code == expected_status, (
            f'Убедитесь, что GET-запрос к `{link}` возвращает ответ со статусом '
            f'{int(expected_status)}.'
        )
E       AssertionError: Убедитесь, что GET-запрос к `https://kittygram-final10.duckdns.org` возвращает ответ со статусом 200.
E       assert 500 == <HTTPStatus.OK: 200>
E        +  where 500 = <Response [500]>.status_code

tests\test_connection.py:49: AssertionError
________________________ test_kittygram_api_available _________________________

self = <Response [400]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv\Lib\site-packages\requests\models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\lager\AppData\Local\Programs\Python\Python312\Lib\json\__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\lager\AppData\Local\Programs\Python\Python312\Lib\json\decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.decoder.JSONDecoder object at 0x0000024929DE9070>
s = '<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta http-equiv="content-type" content="text/html; charset=utf-8">\n  <...      display a standard page generated by the handler for this status code.\n    </p>\n  </div>\n\n</body>\n</html>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

C:\Users\lager\AppData\Local\Programs\Python\Python312\Lib\json\decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

deploy_file_info = (WindowsPath('D:/Dev/kittygram_final/tests.yml'), 'tests.yml')
deploy_info_file_content = {'dockerhub_username': 'pavellagerev', 'kittygram_domain': 'https://kittygram-final10.duckdns.org', 'repo_owner': 'Chashkapluy1', 'taski_domain': 'https://taski-docker10.duckdns.org'}
kittygram_link_key = 'kittygram_domain'

    def test_kittygram_api_available(
            deploy_file_info: tuple[Path, str],
            deploy_info_file_content: dict[str, str],
            kittygram_link_key: str
    ) -> None:
        link = _get_validated_link(deploy_file_info, deploy_info_file_content,
                                   kittygram_link_key)
        signup_link = f'{link}/api/users/'
        form_data = {
            'username': 'newuser',
            'password': ''
        }
        assert_msg = (
            'Убедитесь, что API проекта `Kittygram` доступен по ссылке формата '
            f'`{link}/api/...`.'
        )
        try:
            response = requests.post(signup_link, data=form_data, timeout=15)
        except requests.exceptions.SSLError:
            raise AssertionError(
                f'Убедитесь, что настроили шифрование для `{link}`.'
            )
        except requests.ConnectionError:
            raise AssertionError(assert_msg)
        expected_status = HTTPStatus.BAD_REQUEST
        assert response.status_code == expected_status, assert_msg
        try:
>           response_data = response.json()
                            ^^^^^^^^^^^^^^^

tests\test_connection.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Response [400]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

venv\Lib\site-packages\requests\models.py:980: JSONDecodeError

During handling of the above exception, another exception occurred:

deploy_file_info = (WindowsPath('D:/Dev/kittygram_final/tests.yml'), 'tests.yml')
deploy_info_file_content = {'dockerhub_username': 'pavellagerev', 'kittygram_domain': 'https://kittygram-final10.duckdns.org', 'repo_owner': 'Chashkapluy1', 'taski_domain': 'https://taski-docker10.duckdns.org'}
kittygram_link_key = 'kittygram_domain'

    def test_kittygram_api_available(
            deploy_file_info: tuple[Path, str],
            deploy_info_file_content: dict[str, str],
            kittygram_link_key: str
    ) -> None:
        link = _get_validated_link(deploy_file_info, deploy_info_file_content,
                                   kittygram_link_key)
        signup_link = f'{link}/api/users/'
        form_data = {
            'username': 'newuser',
            'password': ''
        }
        assert_msg = (
            'Убедитесь, что API проекта `Kittygram` доступен по ссылке формата '
            f'`{link}/api/...`.'
        )
        try:
            response = requests.post(signup_link, data=form_data, timeout=15)
        except requests.exceptions.SSLError:
            raise AssertionError(
                f'Убедитесь, что настроили шифрование для `{link}`.'
            )
        except requests.ConnectionError:
            raise AssertionError(assert_msg)
        expected_status = HTTPStatus.BAD_REQUEST
        assert response.status_code == expected_status, assert_msg
        try:
            response_data = response.json()
        except json.JSONDecodeError:
>           raise AssertionError(
                f'Убедитесь, что ответ на запрос к `{signup_link}` содержит '
                'данные в формате JSON.'
            )
E           AssertionError: Убедитесь, что ответ на запрос к `https://kittygram-final10.duckdns.org/api/users/` содержит данные в формате JSON.

tests\test_connection.py:166: AssertionError
____________________ test_docker_compose_prod_file_exists _____________________

base_dir = WindowsPath('D:/Dev/kittygram_final')
docker_compose_prod_file_name = 'docker-compose.production.yml'

    def test_docker_compose_prod_file_exists(base_dir: Path,
                                             docker_compose_prod_file_name: str):
        path_to_file = base_dir / docker_compose_prod_file_name
>       assert path_to_file.is_file(), (
            f'Убедитесь, что корневая директория проекта содержит файл '
            f'`{docker_compose_prod_file_name}`.'
        )
E       AssertionError: Убедитесь, что корневая директория проекта содержит файл `docker-compose.production.yml`.
E       assert False
E        +  where False = is_file()
E        +    where is_file = WindowsPath('D:/Dev/kittygram_final/docker-compose.production.yml').is_file

tests\test_files.py:116: AssertionError
=========================== short test summary info ===========================
FAILED tests/test_connection.py::test_link_connection[kittygram_domain] - AssertionError: Убедитесь, что GET-запрос к `https://kittygram-final10.duckdns.org` возвращает ответ со статусом 200.
assert 500 == <HTTPStatus.OK: 200>
 +  where 500 = <Response [500]>.status_code
FAILED tests/test_connection.py::test_projects_on_same_ip - AssertionError: Убедитесь, что GET-запрос к `https://kittygram-final10.duckdns.org` возвращает ответ со статусом 200.
assert 500 == <HTTPStatus.OK: 200>
 +  where 500 = <Response [500]>.status_code
FAILED tests/test_connection.py::test_kittygram_static_is_available - AssertionError: Убедитесь, что GET-запрос к `https://kittygram-final10.duckdns.org` возвращает ответ со статусом 200.
assert 500 == <HTTPStatus.OK: 200>
 +  where 500 = <Response [500]>.status_code
FAILED tests/test_connection.py::test_kittygram_api_available - AssertionError: Убедитесь, что ответ на запрос к `https://kittygram-final10.duckdns.org/api/users/` содержит данные в формате JSON.
FAILED tests/test_files.py::test_docker_compose_prod_file_exists - AssertionError: Убедитесь, что корневая директория проекта содержит файл `docker-compose.production.yml`.
assert False
 +  where False = is_file()
 +    where is_file = WindowsPath('D:/Dev/kittygram_final/docker-compose.production.yml').is_file
=================== 5 failed, 8 passed, 2 warnings in 7.09s ===================
